// MARK: Variables & Imports
const express = require('express');
const router = express.Router();
const OpenAI = require("openai");
const helpers = require('../helpers');
const multer = require('multer');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();
const { OPENAI_API_KEY } = process.env;
const { REMAKER_API_KEY } = process.env;
const { MongoClient, ObjectId } = require('mongodb');
const mongoUri = 'mongodb://localhost:27017/toga_database';


// MARK: Multer Storage Setup
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, path.join(__dirname, '..', 'public', 'faces')); // save uploads to the 'public/faces' folder
    },
    filename: function (req, file, cb) {
        const uniqueFilename = uuidv4(); // generate a unique UUID for the filename
        const fileExtension = path.extname(file.originalname); // get the original file extension
        const newFilename = `${uniqueFilename}${fileExtension}`; // combine the UUID and file extension
        cb(null, newFilename); // pass the new filename to multer
    }
});
const upload = multer({ storage: storage, limits: { fieldSize: 10 * 1024 * 1024 } });


// MARK: REST Requests
/**
 * @route POST /playground/generate
 * @description // TODO
 * @param {FormData} req.body.categories - The request body containing user clothing selection data.
 * @param {Blob} req.body.face_image - The face image file to overimpose onto the target image generated by DALL-E.
 * @throws {Error} - If something goes wrong during processing
 */
router.post('/playground/generate', upload.single('face_image'), async (req, res) => {

    // incoming face image
    if (!req.file) return res.status(400).send('No file uploaded');
    // const filename = req.file.filename;
    const faceFilePath = path.join(__dirname, '..', 'public', 'faces', req.file.filename);
    const faceImageUrl = 'http://3.20.237.64:80/public/faces/' + req.file.filename;

    try {

        // get clothing and color info using incoming ids from client
        const client = new MongoClient(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
        await client.connect();
        const categoriesObject = JSON.parse(req.body.categories);
        const categoriesCollection = client.db().collection('clothing_categories');
        let clothingProperties = '';
        for (let i = 0; i < categoriesObject.length; i++) {
            const categoryDocument = await categoriesCollection.findOne({ _id: ObjectId(categoriesObject[i]['category_id']) });
            const categoryCollectionName = categoryDocument['name'] + '_category';
            const categoryCollection = client.db().collection(categoryCollectionName);
            const clothingItem = await categoryCollection.findOne({ _id: ObjectId(categoriesObject[i]['selected_clothing_id']) });
            const colorName = categoriesObject[i]['selected_color'][0];
            clothingProperties += ' ' + colorName + ' ' + clothingItem.name + ',';
        }

        // Open AI API
        const prompt = helpers.getPrompt(clothingProperties);
        console.log(prompt);
        const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
        const openaiResponse = await openai.images.generate({ model: "dall-e-3", prompt: prompt, n: 1, size: "1024x1024", });
        console.log('Successfully processed a generation request, OpenAI response: ', openaiResponse);
        const openaiImageId = uuidv4();
        const openaiImageName = openaiImageId + '.png';
        const openaiSavedImageUrl = 'http://3.20.237.64:80/public/targets/' + openaiImageName;
        console.log(openaiSavedImageUrl);
        const openaiSavedImagePath = await helpers.saveImageFromURL(openaiResponse.data[0].url, './public/targets/' + openaiImageName);
        console.log(openaiSavedImagePath);

        // Remaker Face Swap Post
        const remakerPostUrl = 'https://developer.remaker.ai/api/remaker/v1/face-swap/create-job';
        const remakerHeaders = {
            'accept': 'application/json',
            'Authorization': REMAKER_API_KEY,
        };
        const remakerFormData = new FormData();
        const targetImage = fs.readFileSync(openaiSavedImagePath);
        const swapImage = fs.readFileSync(faceFilePath);
        remakerFormData.append('target_image', new Blob([targetImage]));
        remakerFormData.append('swap_image', new Blob([swapImage]));
        const remakerPostResponse = await axios.post(remakerPostUrl, remakerFormData, { headers: remakerHeaders });
        console.log(remakerPostResponse.data);
        const remakerJobId = remakerPostResponse.data.result.job_id;
        console.log(remakerJobId);

        // Remaker Face Swap Get
        const remakerGetUrl = `https://developer.remaker.ai/api/remaker/v1/face-swap/${remakerJobId}`;
        helpers.delay(10000).then(async () => {
            const remakerGetResponse = await axios.get(remakerGetUrl, { headers: remakerHeaders });
            console.log(remakerGetResponse.data);
            const remakerResultUrl = remakerGetResponse.data.result.output_image_url[0];
            console.log(remakerResultUrl);

            const remakerImageId = uuidv4();
            const remakerImageName = remakerImageId + '.png';
            const remakerSavedImageUrl = 'http://3.20.237.64:80/public/results/' + remakerImageName;
            console.log(remakerSavedImageUrl);
            const remakerSavedImagePath = await helpers.saveImageFromURL(remakerResultUrl, './public/results/' + remakerImageName);
            console.log('remaker image saved successfully: ', remakerSavedImagePath);

            const newGenerationItem = helpers.constructGenerationItem(faceImageUrl, openaiSavedImageUrl, remakerSavedImageUrl, Date.now(), 'test-author', categoriesObject);
            const generatedItemsCollection = client.db().collection('generated_items');
            const result = await generatedItemsCollection.insertOne(newGenerationItem);
            console.log('Object inserted with ID:', result.insertedId);
            await client.close();
            console.log('Successfully saved item to mongo:', newGenerationItem);
            res.status(201).json(newGenerationItem);
        });

    } catch (error) {
        console.log('Failed to create a new playground generation item: ', error);
        res.status(500).json({ error });
    }
});



/**
 * @route POST /playground/clothing-categories
 * @description Gets and returns the "clothing_categories" collection from MongoDB (contains a list of base info for all clothing categories).
 * @param {express.Request} req - The request object.
 * @param {express.Response} res - The response object.
 * @returns {Promise<void>} The HTTP response indicating success or failure.
 * @throws {Error} - If something goes wrong during processing
 */
router.get('/playground/clothing-categories', async (req, res) => {
    try {
        const documents = await getClothingCategoriesData();
        return res.status(201).json(documents);
    } catch (e) {
        console.error('Error: ', e);
        return res.status(500).send('Server failed to get and return the data containing base information about all clothing categories.');
    }
});


/**
 * @route POST /playground/category
 * @description Based on the provided clothing category id a list of all clothing items within that category is returned to the client.
 * @param {express.Request} req - The request object.
 * @param {express.Response} res - The response object.
 * @returns {Promise<void>} The HTTP response indicating success or failure.
 * @throws {Error} - If something goes wrong during processing
 */
router.get('/playground/category', async (req, res) => {
    const categoryId = req.query.categoryId;
    if (!categoryId) return res.status(400).send('Missing categoryId');

    try {
        const categoryDocument = await getClothingCategoryData(categoryId);
        if (!categoryDocument) return res.status(404).send(`Category under the provided category id (${categoryId}) was not found in the database.`); // if the category doesn't exist
        const documents = await getClothingCategoryItems(categoryDocument['name'] + '_category')
        return res.status(201).json(documents);
    } catch (e) {
        console.error('Error: ', e);
        return res.status(500).send('Server failed to get items for the clothing category with id: ' + categoryId);
    }
});


// MARK: Processing Functions
/**
 * Connects to MongoDB client and obtains all documents from the "clothing_categories" collection, returning them as an array.
 * @returns {Array} A list of objects where each item contains base data about a particular clothing category.
 */
async function getClothingCategoriesData() {
    const client = new MongoClient(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await client.connect();
    const categoriesCollection = client.db().collection('clothing_categories');
    const categoryDocuments = await categoriesCollection.find({}).toArray();
    await client.close();
    return categoryDocuments;
}

/**
 * Connects to MongoDB client and obtains a single clothing category base data based on the provided category id.
 * @param {string} categoryId - The string id of the returned category.
 * @returns {Object} A single document from the "clothing_categories" collection containing all base information about the given clothing category.
 */
async function getClothingCategoryData(categoryId) {
    const client = new MongoClient(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await client.connect();
    const categoriesCollection = client.db().collection('clothing_categories');
    const categoryDocument = await categoriesCollection.findOne({ _id: ObjectId(categoryId) });
    await client.close();
    return categoryDocument;
}

/**
 * Connects to MongoDB client and obtains all individual clothing item data for a single (provided name) clothing category.
 * @param {string} categoryCollectionName - Clothing category string name.
 * @returns {Array} A list of all clothing item objects from a particular clothing category.
 */
async function getClothingCategoryItems(categoryCollectionName){
    const client = new MongoClient(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await client.connect();
    const categoryCollection = client.db().collection(categoryCollectionName);
    const documents = await categoryCollection.find({}).toArray();
    await client.close();
    return documents;
}


// MARK: Export
module.exports = router;